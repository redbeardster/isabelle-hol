(*<*)
theory sol04
  imports "../../fds_ss17/Demos/BST_Demo"
begin
(*>*)

  
text {* \ExerciseSheet{4}{19.~5.~2017} *}

text \<open>
  \Exercise{Height-Preserving In-Order Join}
  Write a function that joins two binary trees such that
    \<^item> The in-order traversal of the new tree is the concatenation of the in-order traversals of the original tree
    \<^item> The new tree is at most one higher than the highest original tree

  Hint: Once you got the function right, proofs are easy!
\<close>  
fun join :: "'a tree \<Rightarrow> 'a tree \<Rightarrow> 'a tree" 
(*<*)  
  where
"join t Leaf = t" |
"join Leaf t = t" |
"join (Node l1 a1 r1) (Node l2 a2 r2) =
   (case join r1 l2 of
     Leaf \<Rightarrow> Node l1 a1 (Node Leaf a2 r2) |
     Node l b r \<Rightarrow> Node (Node l1 a1 l) b (Node r a2 r2))"
(*>*)

lemma "inorder(join t1 t2) = inorder t1 @ inorder t2"
(*<*)  
apply(induction t1 t2 rule: join.induct)
apply (auto split: tree.split)
done
(*>*)

lemma "height(join t1 t2) \<le> max (height t1) (height t2) + 1"
(*<*)  
apply(induction t1 t2 rule: join.induct)
apply (auto split: tree.split)
done
(*>*)
  
text \<open>
  \Exercise{Enumerate Elements in Interval}  
  Write a function to in-order enumerate all elements of a BST in a given interval.
  I.e., \<open>in_range t u v\<close> shall enumerate all elements \<open>x\<close> with \<open>u\<le>x\<le>v\<close>.
  Write a recursive function that does not descend into nodes that definitely 
  contain no elements in the given range.
\<close>
fun in_range :: "'a::linorder tree \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a list" 
(*<*)    
  where
    "in_range Leaf u v = []"
  | "in_range (Node l x r) u v = 
      (if u<x then in_range l u v else [])
    @ (if u\<le>x \<and> x\<le>v then [x] else [])
    @ (if x<v then in_range r u v else [])
    "  
(*>*)    

text \<open>Show that you enumerate the right set of elements\<close>
lemma "bst t \<Longrightarrow> set (in_range t u v) = {x\<in>set_tree t. u\<le>x \<and> x\<le>v}"    
(*<*)    
  apply (induction t)
  apply auto
  done  
(*>*)    

(*<*)    
lemma [simp]: "[v] = xs@w#ys \<longleftrightarrow> (xs=[] \<and> ys=[] \<and> v=w)"
  by (metis Nil_is_append_conv append_self_conv2 butlast.simps(2) butlast_append list.discI nth_Cons_0)
    
(*lemma [simp]: "NO_MATCH x [] \<Longrightarrow> [] = x \<longleftrightarrow> x = []" by auto  *)
      
lemma [simp]: "[] = filter P x \<longleftrightarrow> filter P x = []" by auto
(*>*)    

text \<open>Show that your enumeration is actually in-order\<close>    
lemma "bst t \<Longrightarrow> in_range t u v = filter (\<lambda>x. u\<le>x \<and> x\<le>v) (inorder t)" 
(*<*)    
  apply (induction t)
  apply (auto simp: filter_empty_conv split!: if_splits)  
  done
(*>*)    
    
    
(*<*)    
  (* Different function, less lemmas \<dots> *)  
  fun in_range' where
    "in_range' Leaf u v = []"
  | "in_range' (Node l x r) u v = 
      (if u\<le>x \<and> x\<le>v then in_range' l u v@x#in_range' r u v
      else if x \<le> v then in_range' r u v
      else if u\<le>x then in_range' l u v
      else []
      )"  
    
    
lemma "bst t \<Longrightarrow> set (in_range' t u v) = {x\<in>set_tree t. u\<le>x \<and> x\<le>v}"    
  apply (induction t)
  apply auto
  done  
  
lemma "bst t \<Longrightarrow> in_range' t u v = filter (\<lambda>x. u\<le>x \<and> x\<le>v) (inorder t)" 
  apply (induction t)
  apply (auto simp: filter_empty_conv) 
  done  
 
(*>*)    

    
text \<open>\Exercise{Pretty Printing of Binary Trees}\<close>

  text \<open>Define a function that checks whether two binary trees have the same 
      structure. The values at the nodes may differ.\<close>
  fun bin_tree2 :: "'a tree \<Rightarrow> 'b tree \<Rightarrow> bool"
  (*<*)  
    where
    "bin_tree2 Leaf Leaf \<longleftrightarrow> True"
  | "bin_tree2 (Node l x r) (Node l' x' r') \<longleftrightarrow> bin_tree2 l l' \<and> bin_tree2 r r'"  
  | "bin_tree2 _ _ \<longleftrightarrow> False"  
  (*>*)

  text \<open>While this function itself is not very useful, the induction rule generated by the function package is!
    It allows simultaneous induction over two trees:\<close>
  print_statement bin_tree2.induct  
    
  text \<open>Binary trees can be uniquely pretty-printed by emitting a symbol L
    for a leaf, and a symbol N for a node. Each N is followed by 
    the pretty-prints of the left and right tree. No additional brackets
    are required!\<close>    

  datatype 'a tchar = L | N 'a
      
  fun pretty :: "'a tree \<Rightarrow> 'a tchar list" 
  (*<*)  
    where
    "pretty Leaf = [L]"
  | "pretty (Node l x r) = N x # pretty l @ pretty r"  
  (*>*)
      
  text \<open>Show that pretty-printing is actually unique, i.e., 
    no two different trees are pretty-printed the same way.
    Hint: Auxiliary lemma. Simultaneous induction over both trees.
  \<close>
  (*<*)  
  lemma pretty_unique_aux: "pretty t @ xs = pretty t' @ xs' \<Longrightarrow> t=t'"
    apply (induction t t' arbitrary: xs xs' rule: bin_tree2.induct)
    apply auto apply fastforce
    done
  (*>*)
    
  lemma pretty_unique: "pretty t = pretty t' \<Longrightarrow> t=t'"
  (*<*)  
    using pretty_unique_aux[where xs="[]" and xs'="[]"] by simp
  (*>*)
    
(*<*)
end
(*>*)

